{
//----------------------------------------------------------------------------
//
// Copyright (c) 2002-2011 Microsoft Corporation. 
//
// This source code is subject to terms and conditions of the Apache License, Version 2.0. A 
// copy of the license can be found in the License.html file at the root of this distribution. 
// By using this source code in any fashion, you are agreeing to be bound 
// by the terms of the Apache License, Version 2.0.
//
// You must not remove this notice, or any other, from this software.
//----------------------------------------------------------------------------

module internal Microsoft.FSharp.Compiler.Lexer

//------------------------------------------------------------------------
// The Lexer.  Some of the complication arises from the fact it is 
// reused by the Visual Studio mode to do partial lexing reporting 
// whitespace etc.
//-----------------------------------------------------------------------

open System.Text
open Internal.Utilities

open Microsoft.FSharp.Compiler.AbstractIL
open Microsoft.FSharp.Compiler.AbstractIL.Internal
open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library
open Microsoft.FSharp.Compiler

open Microsoft.FSharp.Compiler.Range
open Microsoft.FSharp.Compiler.Ast
open Microsoft.FSharp.Compiler.ErrorLogger
open Microsoft.FSharp.Compiler.Parser
open Microsoft.FSharp.Compiler.Lexhelp
open Microsoft.FSharp.Compiler.Lib
open Internal.Utilities.Text.Lexing

let lexeme (lexbuf : UnicodeLexing.Lexbuf) = UnicodeLexing.Lexbuf.LexemeString lexbuf

let trimBoth (s:string) n m = s.Substring(n, s.Length - (n+m))
let lexemeTrimBoth   lexbuf n m = trimBoth (lexeme lexbuf) n m
let lexemeTrimRight  lexbuf n = lexemeTrimBoth lexbuf 0 n
let lexemeTrimLeft   lexbuf n = lexemeTrimBoth lexbuf n 0

let fail args lexbuf msg dflt =
     let m = getLexerRange  lexbuf 
     args.errorLogger.ErrorR(Error(msg,m));
     dflt        
     
let lexemeTrimRightToInt32 args lexbuf n = 
    try int32 (lexemeTrimRight lexbuf n)
    with _ -> fail args lexbuf (FSComp.SR.lexOutsideIntegerRange()) 0

let checkExprOp lexbuf = 
    if String.contains (lexeme lexbuf)  ':' then 
        deprecatedWithError (FSComp.SR.lexCharNotAllowedInOperatorNames(":")) (getLexerRange lexbuf);
    if String.contains (lexeme lexbuf)  '$' then 
        deprecatedWithError (FSComp.SR.lexCharNotAllowedInOperatorNames("$")) (getLexerRange lexbuf) 

let checkPrefixOp lexbuf = 
    let s = lexeme lexbuf 
    if s.[0] = '?' && s <> "?<-" then 
        deprecatedWithError (FSComp.SR.lexOpNamesCannotStartWithQuestionMark()) (getLexerRange lexbuf) 

let unexpectedChar lexbuf =
    LEX_FAILURE (FSComp.SR.lexUnexpectedChar(lexeme lexbuf))

let startString args (lexbuf: UnicodeLexing.Lexbuf) =
    let buf = ByteBuffer.Create 100 
    let m = getLexerRange  lexbuf 
    let startp = lexbuf.StartPos 
    let fin = (fun _m2 b s -> 
                     (* Adjust the start-of-token mark back to the true start of the token *)
                     lexbuf.StartPos <- startp;
                     if b then
                        if Lexhelp.stringBufferIsBytes buf then
                            BYTEARRAY (Lexhelp.stringBufferAsBytes buf)
                        else (
                            fail args lexbuf (FSComp.SR.lexByteArrayCannotEncode()) ();
                            BYTEARRAY (Lexhelp.stringBufferAsBytes buf)
                        )
                     else
                        STRING (System.Text.Encoding.Unicode.GetString(s,0,s.Length)))  
    buf,fin,m
             
(* Utility functions for processing XML documentation *)

let trySaveXmlDoc lexbuf (buff:option<System.Text.StringBuilder>) =
    match buff with 
    | None -> () 
    | Some(sb) -> LexbufLocalXmlDocStore.SaveXmlDoc lexbuf (sb.ToString(), posOfLexPosition lexbuf.StartPos)
  
let tryAppendXmlDoc (buff:option<System.Text.StringBuilder>) (s:string) =
    match buff with 
    | None -> ()
    | Some(sb) -> ignore(sb.Append(s))

(* Utilities for parsing #if/#else/#endif *)

let shouldStartLine args lexbuf (m:range) err tok = 
    if (m.StartColumn <> 0) then fail args lexbuf err tok
    else tok
    
let extractIdentFromHashIf (lexed:string) =
    // Skip the '#if' token, then trim whitespace, then find the end of the identifier
    let lexed = lexed.Trim()      
    let trimIf = lexed.Substring(3).Trim() 
    let identEnd = trimIf.IndexOfAny([| ' '; '\t'; '/' |]) 
    let identEnd = (if identEnd = -1 then trimIf.Length else identEnd)
    trimIf.Substring(0, identEnd)
} 

let letter = '\Lu' | '\Ll' | '\Lt' | '\Lm' | '\Lo' | '\Nl'
let surrogateChar = '\Cs'
let digit = '\Nd'
let hex = ['0'-'9'] | ['A'-'F'] | ['a'-'f']
let truewhite = [' ']
let offwhite = ['\t']
let anywhite = truewhite | offwhite
let op_char = '!'|'$'|'%'|'&'|'*'|'+'|'-'|'.'|'/'|'<'|'='|'>'|'?'|'@'|'^'|'|'|'~'|':'
let ignored_op_char = '.' | '$'
let xinteger = 
  (  '0' ('x'| 'X')  hex + 
   | '0' ('o'| 'O')  (['0'-'7']) + 
   | '0' ('b'| 'B')  (['0'-'1']) + )
let integer = digit+
let int8 = integer 'y'
let uint8 = (xinteger | integer) 'u' 'y' 
let int16 = integer 's'
let uint16 = (xinteger | integer) 'u' 's'
let int = integer 
let int32 = integer 'l'
let uint32 = (xinteger | integer) 'u' 
let uint32l = (xinteger | integer) 'u' 'l'
let nativeint = (xinteger | integer) 'n'
let unativeint = (xinteger | integer) 'u' 'n'
let int64 = (xinteger | integer) 'L' 
let uint64 = (xinteger | integer) ('u' | 'U') 'L' 
let xint8 = xinteger 'y'
let xint16 = xinteger 's'
let xint = xinteger 
let xint32 = xinteger 'l'
let floatp = digit+ '.' digit*  
let floate = digit+ ('.' digit* )? ('e'| 'E') ['+' '-']? digit+
let float = floatp | floate 
let bignum =  integer ('I'  | 'N' | 'Z' | 'Q' | 'R' | 'G')
let ieee64 = float
let ieee32 = float ('f' | 'F') 
let decimal = (float | integer) ('m' | 'M') 
let xieee32 = xinteger 'l' 'f'
let xieee64 = xinteger 'L' 'F'
let escape_char = ('\\' ( '\\' | "\"" | '\'' | 'a' | 'f' | 'v' | 'n' | 't' | 'b' | 'r'))
let char = '\'' ( [^'\\''\n''\r''\t''\b'] | escape_char) '\''
let trigraph = '\\' digit digit digit
let hexGraphShort = '\\' 'x' hex hex 
let unicodeGraphShort = '\\' 'u' hex hex hex hex
let unicodeGraphLong =  '\\' 'U' hex hex hex hex hex hex hex hex
let newline = ('\n' | '\r' '\n')

let connecting_char = '\Pc'
let combining_char = '\Mn' | '\Mc'
let formatting_char = '\Cf' 

let ident_start_char = 
    letter | '_'

let ident_char = 
    letter
  | connecting_char 
  | combining_char 
  | formatting_char 
  | digit 
  | ['\'']
  
let ident = ident_start_char ident_char*

rule token args skip = parse
 | ident 
     { Keywords.KeywordOrIdentifierToken args lexbuf (lexeme lexbuf) }
 | "do!" 
     { DO_BANG } 
 | "yield!" 
     { YIELD_BANG(true)  } 
 | "return!" 
     { YIELD_BANG(false) } 
 | ident '!' 
     { let tok = Keywords.KeywordOrIdentifierToken args lexbuf (lexemeTrimRight lexbuf 1) 
       match tok with 
       | LET _ -> BINDER (lexemeTrimRight lexbuf 1) 
       | _ -> fail args lexbuf (FSComp.SR.lexIdentEndInMarkReserved("!")) (Keywords.KeywordOrIdentifierToken args lexbuf (lexeme lexbuf)) } 
 | ident ('#')  
     { fail args lexbuf (FSComp.SR.lexIdentEndInMarkReserved("#")) (Keywords.KeywordOrIdentifierToken args lexbuf (lexeme lexbuf)) }
 | int8 
     { let n = lexemeTrimRightToInt32 args lexbuf 1 
       if n > 0x80 || n < -0x80 then fail args lexbuf (FSComp.SR.lexOutsideEightBitSigned()) (INT8(0y,false))
    (* Allow <max_int+1> to parse as min_int.  Allowed only because we parse '-' as an operator. *)
       else if n = 0x80 then INT8(sbyte(-0x80), true (* 'true' = 'bad'*) )
       else INT8(sbyte n,false) }
 | xint8 
     { let n = lexemeTrimRightToInt32 args lexbuf 1 
       if n > 0xFF || n < 0 then fail args lexbuf (FSComp.SR.lexOutsideEightBitSignedHex()) (INT8(0y,false))
       else INT8(sbyte(byte(n)),false) }
 | uint8
     { let n = lexemeTrimRightToInt32 args lexbuf 2 
       if n > 0xFF || n < 0 then fail args lexbuf (FSComp.SR.lexOutsideEightBitUnsigned()) (UINT8(0uy))
       else UINT8(byte n) }
 | int16 
     { let n = lexemeTrimRightToInt32 args lexbuf 1 
       if n > 0x8000 || n < -0x8000 then fail args lexbuf (FSComp.SR.lexOutsideSixteenBitSigned()) (INT16(0s,false))
    (* Allow <max_int+1> to parse as min_int.  Allowed only because we parse '-' as an operator. *)
       else if n = 0x8000 then INT16(-0x8000s,true)
       else INT16(int16 n,false) }
 | xint16 
     { let n = lexemeTrimRightToInt32 args lexbuf 1 
       if n > 0xFFFF || n < 0 then fail args lexbuf (FSComp.SR.lexOutsideSixteenBitSigned()) (INT16(0s,false))
       else INT16(int16(uint16(n)),false) }
 | uint16 
     { let n = lexemeTrimRightToInt32 args lexbuf 2 
       if n > 0xFFFF || n < 0 then fail args lexbuf (FSComp.SR.lexOutsideSixteenBitUnsigned()) (UINT16(0us))
       else UINT16(uint16 n) }
 | int '.' '.' 
     { let s = lexemeTrimRight lexbuf 2 
       (* Allow <max_int+1> to parse as min_int.  Allowed only because we parse '-' as an operator. *)
       if s = "2147483648" then INT32_DOT_DOT(-2147483648,true) else
       let n = try int32 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitSigned()) 0
       INT32_DOT_DOT(n,false)
     } 
 | xint 
 | int 
     { let s = lexeme lexbuf 
       (* Allow <max_int+1> to parse as min_int.  Allowed only because we parse '-' as an operator. *)
       if s = "2147483648" then INT32(-2147483648,true) else
       let n =
           try int32 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitSigned()) 0
       INT32(n,false)
     } 
 | xint32 
 | int32 
     { let s = lexemeTrimRight lexbuf 1 
       (* Allow <max_int+1> to parse as min_int.  Allowed only because we parse '-' as an operator. *)
       if s = "2147483648" then INT32(-2147483648,true) else
       let n = 
           try int32 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitSigned()) 0
       INT32(n,false)
     } 

 | uint32
     { 
       let s = lexemeTrimRight lexbuf 1 
       let n = 
           try int64 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitUnsigned()) 0L
       if n > 0xFFFFFFFFL || n < 0L then fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitUnsigned()) (UINT32(0u)) else
       UINT32(uint32 (uint64 n)) } 

 | uint32l
     { 
       let s = lexemeTrimRight lexbuf 2 
       let n = 
           try int64 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitUnsigned()) 0L
       if n > 0xFFFFFFFFL || n < 0L then fail args lexbuf (FSComp.SR.lexOutsideThirtyTwoBitUnsigned()) (UINT32(0u)) else
       UINT32(uint32 (uint64 n)) } 

 | int64 
     { let s = lexemeTrimRight lexbuf 1 
       (* Allow <max_int+1> to parse as min_int.  Stupid but allowed because we parse '-' as an operator. *)
       if s = "9223372036854775808" then INT64(-9223372036854775808L,true) else
       let n = 
          try int64 s with _ ->  fail args lexbuf (FSComp.SR.lexOutsideSixtyFourBitSigned()) 0L
       INT64(n,false)
     }

 | uint64     
     { let s = lexemeTrimRight lexbuf 2 
       let n = 
         try uint64 s with _ -> fail args lexbuf (FSComp.SR.lexOutsideSixtyFourBitUnsigned()) 0UL
       UINT64(n) } 

 | nativeint  
     { try 
           NATIVEINT(int64 (lexemeTrimRight lexbuf 1)) 
       with _ ->  fail args lexbuf (FSComp.SR.lexOutsideNativeSigned()) (NATIVEINT(0L)) } 

 | unativeint 
     { try 
           UNATIVEINT(uint64 (lexemeTrimRight lexbuf 2)) 
       with _ ->  fail args lexbuf (FSComp.SR.lexOutsideNativeUnsigned())  (UNATIVEINT(0UL)) }

 | ieee32     
     { IEEE32 (try float32(lexemeTrimRight lexbuf 1) with _ -> fail args lexbuf (FSComp.SR.lexInvalidFloat()) 0.0f) }
 | ieee64     
     { IEEE64 (try float(lexeme lexbuf) with _ -> fail args lexbuf (FSComp.SR.lexInvalidFloat()) 0.0) }

 | decimal    
     { try 
          let s = lexemeTrimRight lexbuf 1
          (* This implements a range check for decimal literals *)
          let d = System.Decimal.Parse(s,System.Globalization.NumberStyles.AllowExponent ||| System.Globalization.NumberStyles.Number,System.Globalization.CultureInfo.InvariantCulture)
          DECIMAL d 
       with 
          e -> fail args lexbuf (FSComp.SR.lexOusideDecimal()) (DECIMAL (decimal 0))
     }
 | xieee32     
     { 
       let s = lexemeTrimRight lexbuf 2
       (* Even though the intermediate step is an int64, display the "invalid float" message, since it will be less confusing to the user *)
       let n64 = (try (int64 s) with _ -> fail args lexbuf (FSComp.SR.lexInvalidFloat()) 0L) 
       if n64 > 0xFFFFFFFFL || n64 < 0L then fail args lexbuf (FSComp.SR.lexOusideThirtyTwoBitFloat()) (IEEE32 0.0f) else
       IEEE32 (System.BitConverter.ToSingle(System.BitConverter.GetBytes(int32 (uint32 (uint64 n64))),0)) }

 | xieee64     
     { 
       let n64 = (try int64 (lexemeTrimRight lexbuf 2) with _ -> fail args lexbuf (FSComp.SR.lexInvalidFloat()) 0L) 
       IEEE64 (System.BitConverter.Int64BitsToDouble(n64)) }
       
 | bignum     
       { let s = lexeme lexbuf 
         BIGNUM (lexemeTrimRight lexbuf 1, s.[s.Length-1..s.Length-1]) }

 | (int | xint | float) ident_char+
       { fail args lexbuf (FSComp.SR.lexInvalidNumericLiteral()) (INT32(0,false)) }
 
 | char
     { let s = lexeme lexbuf 
       CHAR (if s.[1] = '\\' then escape s.[2] else s.[1])  }

 | char 'B' 
     { let s = lexeme lexbuf 
       let x = int32 (if s.[1] = '\\' then escape s.[2] else s.[1])
       if x < 0 || x > 127 then 
           fail args lexbuf (FSComp.SR.lexInvalidByteLiteral()) (UINT8(byte 0))
       else
           UINT8 (byte(x))  }
     
 | '\'' trigraph '\''
     { let s = lexeme lexbuf 
       let c = trigraph s.[2] s.[3] s.[4] 
       let x = int32 c
       if x < 0 || x > 255 then 
           fail args lexbuf (FSComp.SR.lexInvalidCharLiteral()) (CHAR c)
       else
           CHAR c }

 | '\'' trigraph '\'' 'B'
     { let s = lexeme lexbuf 
       let x = int32 (trigraph s.[2] s.[3] s.[4])
       if x < 0 || x > 255 then 
           fail args lexbuf (FSComp.SR.lexInvalidByteLiteral()) (UINT8(byte 0))
       else
           UINT8 (byte(x))  }

 | '\'' unicodeGraphShort '\''  'B'
     { let x = int32 (unicodeGraphShort (lexemeTrimBoth lexbuf 3 2))
       if x < 0 || x > 127 then 
           fail args lexbuf (FSComp.SR.lexInvalidByteLiteral()) (UINT8(byte 0))
       else
           UINT8 (byte(x))  }
     
 | '\'' hexGraphShort '\'' { CHAR (char (int32 (hexGraphShort (lexemeTrimBoth lexbuf 3 1)))) }
 | '\'' unicodeGraphShort '\'' { CHAR (char (int32 (unicodeGraphShort (lexemeTrimBoth lexbuf 3 1)))) }
 | '\'' unicodeGraphLong '\''  
     { let hi,lo = unicodeGraphLong (lexemeTrimBoth lexbuf 3 1) 
       match hi with 
       | None -> CHAR (char lo)
       | Some _ -> fail args lexbuf  (FSComp.SR.lexThisUnicodeOnlyInStringLiterals()) (CHAR (char lo)) }
 | "(*IF-FSHARP"    { if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
 | "(*F#"           { if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
 | "ENDIF-FSHARP*)" { if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf  }
 | "F#*)"           { if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }

 | "(*)"            { LPAREN_STAR_RPAREN }

 | "(*"
     { let m = getLexerRange  lexbuf 
       if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,1,m))) else comment (1,m,args) skip lexbuf }

 | "(*IF-CAML*)" |  "(*IF-OCAML*)" 
     { let m = getLexerRange  lexbuf 
       if not skip then (COMMENT (LexCont.MLOnly(!args.ifdefStack,m))) else camlonly m args skip lexbuf }

 | '"' 
     { let buf,fin,m = startString args lexbuf 
       if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m))) else string (buf,fin,m,args) skip lexbuf }
      
 | '"' '"' '"' 
     { fail args lexbuf  (FSComp.SR.lexTokenReserved()) (WHITESPACE (LexCont.Token !args.ifdefStack)) }
      
 | '$' '"' 
     { fail args lexbuf  (FSComp.SR.lexTokenReserved()) (WHITESPACE (LexCont.Token !args.ifdefStack)) }
      
 | '@' '"' 
     { let buf,fin,m = startString args lexbuf 
       if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m))) else vstring (buf,fin,m,args) skip lexbuf }

 | truewhite+  
     { if skip then token args skip lexbuf
       else WHITESPACE (LexCont.Token !args.ifdefStack) }

 | offwhite+  
     { if args.lightSyntaxStatus.Status then errorR(Error(FSComp.SR.lexTabsNotAllowed(),getLexerRange lexbuf));
       if not skip then (WHITESPACE (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }

 | "////" op_char* 
     { (* 4+ slash are 1-line comments, online 3 slash are XmlDoc *)
       let m = getLexerRange lexbuf  
       if not skip then (LINE_COMMENT (LexCont.TokenizedComment(!args.ifdefStack,1,m))) else tokenized_comment (None,1,m,args) skip lexbuf }

 | "///" op_char*
     { (* Match exactly 3 slash, 4+ slash caught by preceding rule *)
       let m = getLexerRange lexbuf 
       let doc = lexemeTrimLeft lexbuf 3  
       let sb = (new StringBuilder(100)).Append(doc)
       if not skip then (LINE_COMMENT (LexCont.TokenizedComment(!args.ifdefStack,1,m))) else tokenized_comment (Some(sb),1,m,args) skip lexbuf }

 | "//" op_char*
     { (* Need to read all operator symbols too, otherwise it might be parsed by a rule below *)
       let m = getLexerRange lexbuf 
       if not skip then (LINE_COMMENT (LexCont.TokenizedComment(!args.ifdefStack,1,m))) else tokenized_comment (None,1,m,args) skip lexbuf }

 | newline 
     { newline lexbuf; if not skip then (WHITESPACE (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }

 | '`' '`' ([^'`' '\n' '\r' '\t'] | '`' [^'`''\n' '\r' '\t']) + '`' '`' 
     { Keywords.IdentifierToken args lexbuf (lexemeTrimBoth lexbuf 2 2) }

 | ('#' anywhite* | "#line" anywhite+ ) digit+ anywhite* ('@'? "\"" [^'\n''\r''"']+ '"')? anywhite* newline
     {  let pos = lexbuf.EndPos 
        if skip then 
          let s = lexeme lexbuf 
          let rec parseLeadingDirective n = 
            match s.[n] with 
            | c when c >= 'a' && c <= 'z' -> parseLeadingDirective (n+1) 
            | _ -> parseLeadingWhitespace n // goto the next state
          
          and parseLeadingWhitespace n = 
            match s.[n] with 
            | ' ' | '\t' -> parseLeadingWhitespace (n+1) 
            | _ -> parseLineNumber n n // goto the next state
          
          and parseLineNumber start n = 
            match s.[n] with 
            | c when c >= '0' && c <= '9' -> parseLineNumber start (n+1)
            | _ -> let text =  (String.sub s start (n-start)) 
                   let lineNumber = 
                       try int32 text
                       with err -> errorR(Error(FSComp.SR.lexInvalidLineNumber(text),getLexerRange lexbuf)); 0
                   lineNumber, parseWhitespaceBeforeFile n // goto the next state
          
          and parseWhitespaceBeforeFile n =  
            match s.[n] with 
            | ' ' | '\t' | '@' -> parseWhitespaceBeforeFile (n+1) 
            | '"' -> Some (parseFile (n+1) (n+1))
            | _ -> None
          
          and parseFile start n =   
            match s.[n] with 
            | '"' -> String.sub s start (n-start)  
            | _ -> parseFile start (n+1) 

          // Call the parser
          let line,file = parseLeadingDirective 1 

          // Construct the new position
          lexbuf.EndPos <- 
            {pos with posFileIndex = (match file with Some f -> fileIndexOfFile f | None -> pos.posFileIndex); 
                      posStartOfLineOffset= pos.posColumnOffset;
                      posLineNum=line };
          token args skip lexbuf 
        else 
          if not skip then (HASH_LINE (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
            
 | "<@" { checkExprOp lexbuf; LQUOTE ("<@ @>", false) }
 | "<@@" { checkExprOp lexbuf; LQUOTE ("<@@ @@>", true) }
 | "@>" { checkExprOp lexbuf; RQUOTE ("<@ @>", false) }
 | "@@>" { checkExprOp lexbuf; RQUOTE ("<@@ @@>", true) }
 | '#' { HASH }
 | '&' { AMP }
 | "&&" { AMP_AMP }
 | "||" { BAR_BAR }
 | '\'' { QUOTE }
 | '(' { LPAREN }
 | ')' { RPAREN }
 | '*' { STAR }
 | ',' { COMMA }
 | "->" { RARROW }
 | "?" { QMARK }
 | "??" { QMARK_QMARK }
 | ".." { DOT_DOT }
 | "." { DOT }
 | ":" { COLON }
 | "::" { COLON_COLON }
 | ":>" { COLON_GREATER }
 | "@>." { RQUOTE_DOT ("<@ @>",false) }
 | "@@>." { RQUOTE_DOT ("<@@ @@>",true) }
 | ">|]" { GREATER_BAR_RBRACK }
 | ":?>" { COLON_QMARK_GREATER }
 | ":?" { COLON_QMARK }
 | ":=" { COLON_EQUALS }
 | ";;" { SEMICOLON_SEMICOLON }
 | ";" { SEMICOLON }
 | "<-" { LARROW }
 | "=" { EQUALS }
 | "[" { LBRACK }
 | "[|" { LBRACK_BAR }
 | "<" { LESS false }
 | ">" { GREATER false }
 | "[<" { LBRACK_LESS }
 | "]" { RBRACK }
 | "|]" { BAR_RBRACK }
 | ">]" { GREATER_RBRACK }
 | "{" { LBRACE }
 | "|" { BAR }
 | "}" { RBRACE }
 | "$" { DOLLAR }
 | "%" { PERCENT_OP("%") }
 | "%%" { PERCENT_OP("%%") }
 | "-" { MINUS }
 | "~" { RESERVED }
 | "`" { RESERVED }
 | ignored_op_char* '*' '*'                    op_char* { checkExprOp lexbuf; INFIX_STAR_STAR_OP(lexeme lexbuf) }
 | ignored_op_char* ('*' | '/'|'%')            op_char* { checkExprOp lexbuf; INFIX_STAR_DIV_MOD_OP(lexeme lexbuf) }
 | ignored_op_char* ('+'|'-')                  op_char* { checkExprOp lexbuf; PLUS_MINUS_OP(lexeme lexbuf) }
 | ignored_op_char* ('@'|'^')                  op_char* { checkExprOp lexbuf; INFIX_AT_HAT_OP(lexeme lexbuf) }
 | ignored_op_char* ('=' | "!=" | '<' | '>' | '$')  op_char* { checkExprOp lexbuf; INFIX_COMPARE_OP(lexeme lexbuf) }
 | ignored_op_char* ('&')                      op_char* { checkExprOp lexbuf; INFIX_AMP_OP(lexeme lexbuf) }
 | ignored_op_char* '|'                        op_char* { checkExprOp lexbuf; INFIX_BAR_OP(lexeme lexbuf) }
 | ignored_op_char* ('!' | '?' | '~' )         op_char* { checkExprOp lexbuf; checkPrefixOp lexbuf; PREFIX_OP(lexeme lexbuf) }
 | ".[]"  | ".[]<-" | ".[,]<-" | ".[,,]<-" | ".[,,,]<-" | ".[,,,]" | ".[,,]" | ".[,]" | ".[..]" | ".[..,..]" | ".[..,..,..]" | ".[..,..,..,..]"
 | ".()"  | ".()<-"  { FUNKY_OPERATOR_NAME(lexeme lexbuf) }

 | "#light" anywhite* 
 | ("#indent" | "#light") anywhite+ "\"on\""
   { if args.lightSyntaxStatus.ExplicitlySet && args.lightSyntaxStatus.WarnOnMultipleTokens then 
         warning(Error((0,"#light should only occur as the first non-comment text in an F# source file"),getLexerRange lexbuf));
     args.lightSyntaxStatus.Status <- true; 
     if not skip then (HASH_LIGHT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf } 

 | ("#indent" | "#light") anywhite+ "\"off\"" 
   { args.lightSyntaxStatus.Status <- false; 
     mlCompatWarning (FSComp.SR.lexIndentOffForML()) (getLexerRange lexbuf);
     if not skip then (HASH_LIGHT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf } 
   
 | anywhite* "#if" anywhite+ ident anywhite* ("//" [^'\n''\r']*)?
   { let m = getLexerRange lexbuf    
     let lexed = lexeme lexbuf
     let id = extractIdentFromHashIf lexed
     args.ifdefStack := (IfDefIf,m) :: !(args.ifdefStack);
     
     // Get the token; make sure it starts at zero position & return
     let cont, f = 
       ( if List.mem id args.defines then (LexCont.EndLine(LexerEndlineContinuation.Token(!args.ifdefStack)), endline (LexerEndlineContinuation.Token !args.ifdefStack) args skip)
         else (LexCont.EndLine(LexerEndlineContinuation.Skip(!args.ifdefStack,0,m)), endline (LexerEndlineContinuation.Skip(!args.ifdefStack,0,m)) args skip) )         
     let tok = shouldStartLine args lexbuf m (FSComp.SR.lexHashIfMustBeFirst()) (HASH_IF(m,lexed,cont))
     if not skip then tok else f lexbuf }

 | anywhite* "#else" anywhite* ("//" [^'\n''\r']*)?
   { let lexed = (lexeme lexbuf)
     match !(args.ifdefStack) with
     | [] ->  LEX_FAILURE (FSComp.SR.lexHashElseNoMatchingIf())
     | (IfDefElse,_) :: _rest -> LEX_FAILURE (FSComp.SR.lexHashEndifRequiredForElse())
     | (IfDefIf,_) :: rest -> 
       let m = getLexerRange  lexbuf 
       args.ifdefStack := (IfDefElse,m) :: rest;
       let tok = HASH_ELSE(m,lexed, LexCont.EndLine(LexerEndlineContinuation.Skip(!args.ifdefStack,0,m)))
       let tok = shouldStartLine args lexbuf m (FSComp.SR.lexHashElseMustBeFirst()) tok
       if not skip then tok else endline (LexerEndlineContinuation.Skip(!args.ifdefStack,0,m)) args skip lexbuf }

 | anywhite* "#endif" anywhite* ("//" [^'\n''\r']*)?
   { let lexed = (lexeme lexbuf) 
     let m = getLexerRange lexbuf  
     match !(args.ifdefStack) with
     | []->  LEX_FAILURE (FSComp.SR.lexHashEndingNoMatchingIf())
     | _ :: rest ->  
        args.ifdefStack := rest;          
        let tok = HASH_ENDIF(m,lexed,LexCont.EndLine(LexerEndlineContinuation.Token(!args.ifdefStack))) 
        let tok = shouldStartLine args lexbuf m (FSComp.SR.lexHashEndifMustBeFirst()) tok 
        if not skip then tok else endline (LexerEndlineContinuation.Token(!args.ifdefStack)) args skip lexbuf }

 | "#if" 
   { let tok = fail args lexbuf (FSComp.SR.lexHashIfMustHaveIdent()) (WHITESPACE (LexCont.Token !args.ifdefStack)) 
     if not skip then tok else token args skip lexbuf }

 | surrogateChar surrogateChar
 | _ 
   { unexpectedChar lexbuf }     
 | eof 
   { EOF (LexCont.Token !args.ifdefStack) }

(* Skips INACTIVE code until if finds #else / #endif matching with the #if or #else *)

and ifdef_skip n m args skip = parse               
 | anywhite* "#if" anywhite+ ident anywhite* ("//" [^'\n''\r']*)?
   { let m = getLexerRange lexbuf     
     let _id = extractIdentFromHashIf (lexeme lexbuf) 
     
     // If #if is the first thing on the line then increase depth, otherwise skip, because it is invalid (e.g. "(**) #if ...")
     if (m.StartColumn <> 0) then
       if not skip then (INACTIVECODE (LexCont.IfDefSkip(!args.ifdefStack,n,m))) else ifdef_skip n m args skip lexbuf
     else
       let tok = INACTIVECODE(LexCont.EndLine(LexerEndlineContinuation.Skip(!args.ifdefStack,n+1,m))) 
       if not skip then tok else endline (LexerEndlineContinuation.Skip(!args.ifdefStack,n+1,m)) args skip lexbuf }

  | anywhite* "#else" anywhite* ("//" [^'\n''\r']*)?
    { let lexed = (lexeme lexbuf) 
      let m = getLexerRange  lexbuf  
           
      // If #else is the first thing on the line then process it, otherwise ignore, because it is invalid (e.g. "(**) #else ...")
      if (m.StartColumn <> 0) then
        if not skip then (INACTIVECODE (LexCont.IfDefSkip(!args.ifdefStack,n,m))) else ifdef_skip n m args skip lexbuf
      elif n = 0 then 
         match !(args.ifdefStack) with
         | []->  LEX_FAILURE (FSComp.SR.lexHashElseNoMatchingIf())
         | (IfDefElse,_) :: _rest -> LEX_FAILURE (FSComp.SR.lexHashEndifRequiredForElse())
         | (IfDefIf,_) :: rest -> 
           let m = getLexerRange  lexbuf  
           args.ifdefStack := (IfDefElse,m) :: rest;
           if not skip then (HASH_ELSE(m,lexed,LexCont.EndLine(LexerEndlineContinuation.Token(!args.ifdefStack)))) else endline (LexerEndlineContinuation.Token(!args.ifdefStack)) args skip lexbuf 
       else
         if not skip then (INACTIVECODE(LexCont.EndLine(LexerEndlineContinuation.Skip(!args.ifdefStack,n,m)))) else endline (LexerEndlineContinuation.Skip(!args.ifdefStack,n,m)) args skip lexbuf }
          
  | anywhite* "#endif" anywhite* ("//" [^'\n''\r']*)?
    { let lexed = lexeme lexbuf
      let m = getLexerRange  lexbuf  
      
      // If #endif is the first thing on the line then process it, otherwise ignore, because it is invalid (e.g. "(**) #endif ...")
      if (m.StartColumn <> 0) then
          if not skip then (INACTIVECODE (LexCont.IfDefSkip(!args.ifdefStack,n,m))) else ifdef_skip n m args skip lexbuf
      elif n = 0 then 
          match !(args.ifdefStack) with
          | [] ->  LEX_FAILURE (FSComp.SR.lexHashEndingNoMatchingIf())
          | _ :: rest -> 
              args.ifdefStack := rest;
              if not skip then (HASH_ENDIF(m,lexed,LexCont.EndLine(LexerEndlineContinuation.Token(!args.ifdefStack)))) else endline (LexerEndlineContinuation.Token(!args.ifdefStack)) args skip lexbuf 
       else
           let tok = INACTIVECODE(LexCont.EndLine(LexerEndlineContinuation.Skip(!args.ifdefStack,n-1,m))) in
           let tok = shouldStartLine args lexbuf m (FSComp.SR.lexWrongNestedHashEndif()) tok in
           if not skip then tok else endline (LexerEndlineContinuation.Skip(!args.ifdefStack,(n-1),m)) args skip lexbuf }
           
  | newline 
    { newline lexbuf; ifdef_skip n m args skip lexbuf }
    
  | [^ ' ' '\n' '\r' ]+
  | anywhite+
  | surrogateChar surrogateChar
  | _    
    { // This tries to be nice and get tokens as 'words' because VS uses this when selecting stuff
      if not skip then (INACTIVECODE (LexCont.IfDefSkip(!args.ifdefStack,n,m))) else ifdef_skip n m args skip lexbuf }
  | eof  
    { EOF (LexCont.IfDefSkip(!args.ifdefStack,n,m)) }

(* Called after lexing #if IDENT/#else/#endif - this checks whether there is nothing except end of line *)
(* or end of file and then calls the lexing function specified by 'cont' - either token or ifdef_skip *)
and endline cont args skip = parse
 | newline
   { newline lexbuf; 
     match cont with
     | LexerEndlineContinuation.Token(ifdefStack) -> if not skip then (WHITESPACE(LexCont.Token ifdefStack)) else token args skip lexbuf
     | LexerEndlineContinuation.Skip(ifdefStack, n, m) -> if not skip then (INACTIVECODE (LexCont.IfDefSkip(ifdefStack,n,m))) else ifdef_skip n m args skip lexbuf
   }
 | eof
   { match cont with
     | LexerEndlineContinuation.Token(ifdefStack) -> (EOF(LexCont.Token ifdefStack))
     | LexerEndlineContinuation.Skip(ifdefStack, n, m) -> (EOF(LexCont.IfDefSkip(ifdefStack,n,m)))
   }
 | [^'\r' '\n']+
 | _
   { let tok = fail args lexbuf (FSComp.SR.lexExpectedSingleLineComment()) (WHITESPACE (LexCont.Token !args.ifdefStack)) in
     if not skip then tok else token args skip lexbuf }     

and string sargs skip = parse
 |  '\\' newline anywhite* 
    { let (_buf,_fin,m,args) = sargs in 
      newline lexbuf; 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 |  escape_char
    { let (buf,_fin,m,args) = sargs in 
      addByteChar buf (escape (lexeme lexbuf).[1]);
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf } 

 | trigraph
    { let (buf,_fin,m,args) = sargs in 
      let s = lexeme lexbuf in 
      addByteChar buf (trigraph s.[1] s.[2] s.[3]);
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 | hexGraphShort
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeChar buf (int (hexGraphShort (lexemeTrimLeft lexbuf 2)));
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf  }
      
 | unicodeGraphShort
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeChar buf (int (unicodeGraphShort (lexemeTrimLeft lexbuf 2)));
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf  }
     
 | unicodeGraphLong
    { let (buf,_fin,m,args) = sargs in 
      let hi,lo = unicodeGraphLong (lexemeTrimLeft lexbuf 2) in 
      (match hi with | None -> () | Some c -> addUnicodeChar buf (int c));
      addUnicodeChar buf (int lo);
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m))) else string sargs skip lexbuf  }
     
 |  '"' 
    { let (buf,fin,_m,_args) = sargs in 
      let m2 = getLexerRange lexbuf in 
      callStringFinisher fin buf m2 false }

 |  '"''B' 
    { let (buf,fin,_m,_args) = sargs in 
      let m2 = getLexerRange lexbuf in 
      callStringFinisher fin buf m2 true }

 | newline
    { let (buf,_fin,m,args) = sargs in 
      newline lexbuf; 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 | ident  
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 | integer 
 | xinteger
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 | anywhite +  
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m)))  else string sargs skip lexbuf }

 | eof  
    { let (_buf,_fin,m,args) = sargs in 
      EOF (LexCont.String(!args.ifdefStack,m)) }
 | surrogateChar surrogateChar // surrogate code points always come in pairs      
 | _ 
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.String(!args.ifdefStack,m))) else string sargs skip lexbuf }

and vstring sargs skip = parse
 |  '"' '"'
   { let (buf,_fin,m,args) = sargs in 
     addByteChar buf '\"';
     if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m)))  else vstring sargs skip lexbuf } 

 |  '"' 
    { let (buf,fin,_m,_args) = sargs in 
      let m2 = getLexerRange lexbuf in 
      callStringFinisher fin buf m2 false }

 |  '"''B' 
    { let (buf,fin,_m,_args) = sargs in 
      let m2 = getLexerRange lexbuf in 
      callStringFinisher fin buf m2 true }

 | newline 
    { let (buf,_fin,m,args) = sargs in 
      newline lexbuf; 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m)))  else vstring sargs skip lexbuf }

 | ident  
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m)))  else vstring sargs skip lexbuf }

 | integer 
 | xinteger
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m)))  else vstring sargs skip lexbuf }

 | anywhite +  
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m)))  else vstring sargs skip lexbuf }

 | eof 
    { let (_buf,_fin,m,args) = sargs in 
      EOF (LexCont.VerbatimString(!args.ifdefStack,m)) }
 | surrogateChar surrogateChar // surrogate code points always come in pairs            
 | _ 
    { let (buf,_fin,m,args) = sargs in 
      addUnicodeString buf (lexeme lexbuf); 
      if not skip then (STRING_TEXT (LexCont.VerbatimString(!args.ifdefStack,m))) else vstring sargs skip lexbuf }

(* Parsing single-line comment - we need to split it into words for Visual Studio IDE *)
and tokenized_comment cargs skip = parse 
 | newline
     { let buff,_n,_m,args = cargs in 
       trySaveXmlDoc lexbuf buff;
       newline lexbuf; 
       (* saves the documentation (if we're collecting any) into a buffer-local variable *)
       if not skip then (LINE_COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
 
 | eof 
     { let _, _n,_m,args = cargs in 
       EOF (LexCont.Token !args.ifdefStack) } (* NOTE: it is legal to end a file with this comment, so we'll return EOF as a token *)
      
 | [^ ' ' '\n' '\r' ]+
 | anywhite+
     { let buff,n,m,args = cargs in 
       (* Append the current token to the XML documentation if we're collecting it *)
       tryAppendXmlDoc buff (lexeme lexbuf);
       if not skip then (LINE_COMMENT (LexCont.TokenizedComment(!args.ifdefStack,n,m))) else tokenized_comment (buff,n,m,args) skip lexbuf  } 
       
 | surrogateChar surrogateChar
 | _ { let _, _n,_m,args = cargs in 
      if not skip then (LINE_COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }

       
and comment cargs skip = parse
 |  char
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment (n,m,args) skip lexbuf  } 
    
 | '"'   
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.CommentString(!args.ifdefStack,n,m))) else comment_string n m args skip lexbuf }

 | '@' '"'
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.CommentVerbatimString(!args.ifdefStack,n,m))) else comment_vstring n m args skip lexbuf }

 | "(*)"
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment cargs skip lexbuf }

 | '(' '*'
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n+1,m))) else comment (n+1,m,args) skip lexbuf }
     
 | newline
    { let n,m,args = cargs in 
      newline lexbuf; 
      if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment cargs skip lexbuf }
 | "*)" 
    { 
      let n,m,args = cargs in 
      if n > 1 then if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n-1,m))) else comment (n-1,m,args) skip lexbuf 
      else if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
      
 | anywhite+
 | [^ '\'' '(' '*' '\n' '\r' '"' ')' '@' ' ' '\t' ]+  
    { let n,m,args = cargs in 
      if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment cargs skip lexbuf }
    
 | eof 
     { let n,m,args = cargs in 
       EOF (LexCont.Comment(!args.ifdefStack,n,m)) }
     
 | surrogateChar surrogateChar
 | _ { let n,m,args = cargs in 
       if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment (n,m,args) skip lexbuf }

and comment_string n m args skip = parse
 (* Follow string lexing, skipping tokens until it finishes *)
 |  '\\' newline anywhite* 
     { newline lexbuf; 
       if not skip then (COMMENT (LexCont.CommentString(!args.ifdefStack,n,m))) else comment_string n m args skip lexbuf }

 | escape_char
 | trigraph
 | hexGraphShort
 | unicodeGraphShort
 | unicodeGraphLong
 | ident  
 | integer
 | xinteger
 | anywhite +  
     { if not skip then (COMMENT (LexCont.CommentString(!args.ifdefStack,n,m))) else comment_string n m args skip lexbuf }


 | '"' 
     { if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment (n,m,args) skip lexbuf }
     
 | newline 
     { newline lexbuf;  
       if not skip then (COMMENT (LexCont.CommentString(!args.ifdefStack,n,m))) else comment_string n m args skip lexbuf }
     
 | eof 
     { EOF (LexCont.CommentString(!args.ifdefStack,n,m)) }
     
 | surrogateChar surrogateChar
 | _  
     { if not skip then (COMMENT (LexCont.CommentString(!args.ifdefStack,n,m))) else comment_string n m args skip lexbuf }

and comment_vstring n m args skip = parse
 (* Follow vstring lexing, in short, skip double-quotes and other chars until we hit a single quote *)
 | '"' '"'
     { if not skip then (COMMENT (LexCont.CommentVerbatimString(!args.ifdefStack,n,m))) else comment_vstring n m args skip lexbuf }

 | '"' 
     { if not skip then (COMMENT (LexCont.Comment(!args.ifdefStack,n,m))) else comment (n,m,args) skip lexbuf }

 | ident  
 | integer 
 | xinteger
 | anywhite +  
     { if not skip then (COMMENT (LexCont.CommentVerbatimString(!args.ifdefStack,n,m))) else comment_vstring n m args skip lexbuf }
     
 | newline 
     { newline lexbuf;
       if not skip then (COMMENT (LexCont.CommentVerbatimString(!args.ifdefStack,n,m))) else comment_vstring n m args skip lexbuf }
     
 | eof 
     { EOF (LexCont.CommentVerbatimString(!args.ifdefStack,n,m)) }
 
 | surrogateChar surrogateChar
 | _  
     { if not skip then (COMMENT (LexCont.CommentVerbatimString(!args.ifdefStack,n,m))) else comment_vstring n m args skip lexbuf }
     
and camlonly m args skip = parse
 | "\""
     { let buf = ByteBuffer.Create 100 in 
       let m2 = getLexerRange  lexbuf in 
       let _ = string (buf,defaultStringFinisher,m2,args) skip lexbuf in  
       if not skip then (COMMENT (LexCont.MLOnly(!args.ifdefStack,m))) else camlonly m args skip lexbuf }
 | newline { newline lexbuf;  if not skip then (COMMENT (LexCont.MLOnly(!args.ifdefStack,m))) else camlonly m args skip lexbuf }
 | "(*ENDIF-CAML*)"  {  if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
 | "(*ENDIF-OCAML*)" {  if not skip then (COMMENT (LexCont.Token !args.ifdefStack)) else token args skip lexbuf }
 | [^ '(' '"' '\n' '\r' ]+  { if not skip then (COMMENT (LexCont.MLOnly(!args.ifdefStack,m))) else camlonly m args skip lexbuf }
 | eof { EOF (LexCont.MLOnly(!args.ifdefStack,m)) }
 | surrogateChar surrogateChar 
 | _ {  if not skip then (COMMENT (LexCont.MLOnly(!args.ifdefStack,m))) else camlonly m args skip lexbuf }
